import {
  DemoInventoryTurnover,
  generateDummyInventoryItem,
  generateDummyInventoryList,
  InventoryData,
} from "@/app/pages/Inventory/demo";

describe("Inventory Demo Data", () => {
  // Store original crypto to restore after modifying environment
  const originalCrypto = globalThis.crypto;

  afterEach(() => {
    // Restore the environment state
    Object.defineProperty(globalThis, "crypto", {
      value: originalCrypto,
      writable: true,
    });
    jest.restoreAllMocks();
  });

  // --- Section 1: Static Data ---

  it("exports valid DemoInventoryTurnover data", () => {
    expect(DemoInventoryTurnover).toBeInstanceOf(Array);
    expect(DemoInventoryTurnover.length).toBeGreaterThan(0);

    // Validate one item structure
    const item = DemoInventoryTurnover[0];
    expect(item).toHaveProperty("name", "Paracetamol 500mg");
    expect(item).toHaveProperty("category", "Medicine");
    expect(item).toHaveProperty("turnsPerYear", 12);
  });

  it("exports pre-generated InventoryData", () => {
    expect(InventoryData).toHaveLength(10);
    expect(InventoryData[0].basicInfo.name).toBeDefined();
  });

  // --- Section 2: Generators & Formats ---

  it("generates a single item with correct structure", () => {
    const item = generateDummyInventoryItem("HOSPITAL");

    // Check high-level objects
    expect(item).toHaveProperty("basicInfo");
    expect(item).toHaveProperty("classification");
    expect(item).toHaveProperty("pricing");
    expect(item).toHaveProperty("vendor");
    expect(item).toHaveProperty("stock");
    expect(item).toHaveProperty("batch");

    // Check specific formats generated by helpers
    // rand() -> "Prefix-Numbers"
    expect(item.basicInfo.name).toMatch(/Item-\d+/);
    expect(item.basicInfo.skuCode).toMatch(/SKU-\d+/);

    // randomDate() -> "YYYY-MM-DD"
    expect(item.batch.manufactureDate).toMatch(/^\d{4}-\d{2}-\d{2}$/);
    expect(item.batch.expiryDate).toMatch(/^\d{4}-\d{2}-\d{2}$/);
  });

  it("generates a list with specified count", () => {
    const count = 5;
    // Changed "CLINIC" to "HOSPITAL" to ensure valid category options exist
    const list = generateDummyInventoryList("HOSPITAL", count);

    expect(list).toHaveLength(count);
    expect(list[0].basicInfo).toBeDefined();
  });

  it("defaults to 10 items if count is not provided", () => {
    // Calling without second argument to test default parameter
    const list = generateDummyInventoryList("HOSPITAL");
    expect(list).toHaveLength(10);
  });

  // --- Section 3: Branch Coverage (secureRandom) ---

  it("uses crypto.getRandomValues when available (Secure Path)", () => {
    const mockGetRandomValues = jest.fn((buf) => {
      // Fill buffer with a deterministic number to ensure predictable logic flow
      buf[0] = 123456;
      return buf;
    });

    Object.defineProperty(globalThis, "crypto", {
      value: { getRandomValues: mockGetRandomValues },
      writable: true,
    });

    const mathSpy = jest.spyOn(Math, "random");

    generateDummyInventoryItem("HOSPITAL");

    expect(mockGetRandomValues).toHaveBeenCalled();
    expect(mathSpy).not.toHaveBeenCalled();
  });

  it("falls back to Math.random when crypto is undefined (Insecure Path 1)", () => {
    // Simulate environment without crypto (e.g., older browsers)
    Object.defineProperty(globalThis, "crypto", {
      value: undefined,
      writable: true,
    });

    const mathSpy = jest.spyOn(Math, "random");

    generateDummyInventoryItem("HOSPITAL");

    expect(mathSpy).toHaveBeenCalled();
  });

  it("falls back to Math.random when getRandomValues is missing (Insecure Path 2)", () => {
    // Simulate environment with crypto but missing the specific function
    Object.defineProperty(globalThis, "crypto", {
      value: {}, // Empty object
      writable: true,
    });

    const mathSpy = jest.spyOn(Math, "random");

    generateDummyInventoryItem("HOSPITAL");

    expect(mathSpy).toHaveBeenCalled();
  });
});