"use strict";(self.webpackChunkdev_docs=self.webpackChunkdev_docs||[]).push([[566],{526:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"guides/backend-chat-implementation","title":"Backend Chat Implementation","description":"(Source: Guides/BACKENDCHATIMPLEMENTATION.md)","source":"@site/docs/guides/backend-chat-implementation.md","sourceDirName":"guides","slug":"/guides/backend-chat","permalink":"/dev-docs/guides/backend-chat","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":null,"frontMatter":{"id":"backend-chat-implementation","title":"Backend Chat Implementation","slug":"/guides/backend-chat"},"sidebar":"docs","previous":{"title":"Notification Setup Guide","permalink":"/dev-docs/guides/notification-setup"},"next":{"title":"Frontend App README","permalink":"/dev-docs/apps/frontend"}}');var r=t(5723),a=t(2303);const i={id:"backend-chat-implementation",title:"Backend Chat Implementation",slug:"/guides/backend-chat"},c="Stream Chat Backend Implementation Guide",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Current Flow (Development)",id:"current-flow-development",level:3},{value:"Required Flow (Production)",id:"required-flow-production",level:3},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Required Endpoints",id:"required-endpoints",level:2},{value:"1. Generate Stream User Token",id:"1-generate-stream-user-token",level:3},{value:"2. Create or Get Appointment Channel",id:"2-create-or-get-appointment-channel",level:3},{value:"3. End/Close Chat Channel",id:"3-endclose-chat-channel",level:3},{value:"4. Get Active Channels for User",id:"4-get-active-channels-for-user",level:3},{value:"5. Webhook Handler (Optional but Recommended)",id:"5-webhook-handler-optional-but-recommended",level:3},{value:"Environment Variables",id:"environment-variables",level:2},{value:"Database Schema Updates",id:"database-schema-updates",level:2},{value:"Current Frontend Implementation",id:"current-frontend-implementation",level:2},{value:"Mobile App (React Native)",id:"mobile-app-react-native",level:3},{value:"Web App (Next.js)",id:"web-app-nextjs",level:3},{value:"Integration Steps",id:"integration-steps",level:2},{value:"Security Checklist",id:"security-checklist",level:2},{value:"Testing",id:"testing",level:2},{value:"Test Token Generation",id:"test-token-generation",level:3},{value:"Test Channel Creation",id:"test-channel-creation",level:3},{value:"Test Get Channels",id:"test-get-channels",level:3},{value:"Deployment Notes",id:"deployment-notes",level:2},{value:"Support",id:"support",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"(Source: Guides/BACKEND_CHAT_IMPLEMENTATION.md)"}),"\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"stream-chat-backend-implementation-guide",children:"Stream Chat Backend Implementation Guide"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"This guide is for backend engineers implementing Stream Chat token generation, channel management, and webhook handlers for the Yosemite Crew veterinary app."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Current Status"}),": Frontend implementation is complete and working. Backend needs to replace mock services with real API endpoints."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"current-flow-development",children:"Current Flow (Development)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Mobile App \u2192 Uses Mock Services (devToken) \u2192 Stream Cloud\nWeb App    \u2192 Uses Mock Services (devToken) \u2192 Stream Cloud\n"})}),"\n",(0,r.jsx)(n.h3,{id:"required-flow-production",children:"Required Flow (Production)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Mobile App \u2192 Request Token \u2192 Backend API \u2192 Stream Cloud\nWeb App    \u2192 Request Token \u2192 Backend API \u2192 Stream Cloud\nBackend    \u2192 Uses API Secret to Create Channels & Tokens\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stream Account"}),": ",(0,r.jsx)(n.a,{href:"https://getstream.io/chat/",children:"https://getstream.io/chat/"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"API Credentials"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"API Key (expose to frontend)"}),"\n",(0,r.jsx)(n.li,{children:"API Secret (keep secure on backend only)"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Node.js >= 20"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Backend Framework"}),": Express, NestJS, or your preference"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"required-endpoints",children:"Required Endpoints"}),"\n",(0,r.jsx)(n.h3,{id:"1-generate-stream-user-token",children:"1. Generate Stream User Token"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Create secure authentication tokens for users to connect to Stream Chat"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Endpoint"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"POST /api/chat/token\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Request"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"{\n  userId: string;  // User ID from your auth system\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Response"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"{\n  token: string;\n  expiresAt: number;  // Unix timestamp\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementation"})," (Express.js):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const StreamChat = require('stream-chat').StreamChat;\n\napp.post('/api/chat/token', async (req, res) => {\n  try {\n    const { userId } = req.body;\n\n    // Verify user is authenticated\n    const user = req.user;  // From auth middleware\n    if (!user || user.id !== userId) {\n      return res.status(401).json({ error: 'Unauthorized' });\n    }\n\n    // Initialize Stream server client\n    const serverClient = StreamChat.getInstance(\n      process.env.STREAM_API_KEY,\n      process.env.STREAM_API_SECRET\n    );\n\n    // Generate token (expires in 24 hours)\n    const token = serverClient.createToken(userId);\n\n    res.json({\n      token,\n      expiresAt: Date.now() + 24 * 60 * 60 * 1000,\n    });\n  } catch (error) {\n    console.error('[Stream] Token generation error:', error);\n    res.status(500).json({ error: 'Failed to generate token' });\n  }\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Frontend Usage"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Mobile App - in streamChatService.ts\nexport const connectStreamUser = async (\n  userId: string,\n  userName: string,\n  userImage?: string,\n) => {\n  const client = getChatClient();\n\n  if (client.userID === userId) {\n    return client;\n  }\n\n  try {\n    // Get token from backend\n    const response = await fetch('/api/chat/token', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ userId }),\n    });\n    const { token } = await response.json();\n\n    await client.connectUser(\n      {\n        id: userId,\n        name: userName,\n        image: userImage,\n      },\n      token  // Use backend-generated token\n    );\n\n    return client;\n  } catch (error) {\n    console.error('[Stream] Failed to connect user:', error);\n    throw error;\n  }\n};\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"2-create-or-get-appointment-channel",children:"2. Create or Get Appointment Channel"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Create a chat channel for an appointment or retrieve existing one"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Endpoint"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"POST /api/chat/channels\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Request"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"{\n  appointmentId: string;\n  petOwnerId: string;\n  vetId: string;\n  appointmentTime: string;  // ISO 8601 format\n  activationMinutes?: number;  // Default: 5\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Response"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"{\n  channelId: string;\n  channelType: 'messaging';\n  members: string[];\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"app.post('/api/chat/channels', async (req, res) => {\n  try {\n    const {\n      appointmentId,\n      petOwnerId,\n      vetId,\n      appointmentTime,\n      activationMinutes = 5,\n    } = req.body;\n\n    // Verify appointment exists and user has access\n    const appointment = await Appointment.findById(appointmentId);\n    if (!appointment) {\n      return res.status(404).json({ error: 'Appointment not found' });\n    }\n\n    // Verify vet owns this appointment\n    if (appointment.vetId !== req.user.id && req.user.role !== 'admin') {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n\n    const serverClient = StreamChat.getInstance(\n      process.env.STREAM_API_KEY,\n      process.env.STREAM_API_SECRET\n    );\n\n    const channelId = `appointment-${appointmentId}`;\n\n    // Create channel\n    const channel = serverClient.channel('messaging', channelId, {\n      name: `Chat with ${appointment.petOwnerName || 'Pet Owner'}`,\n      members: [petOwnerId, vetId],\n      appointmentId,\n      appointmentTime,\n      activationMinutes,\n      status: 'active',\n      created_by_id: vetId,\n    });\n\n    await channel.create();\n\n    // Store channel reference in database (optional but recommended)\n    await Appointment.updateOne(\n      { _id: appointmentId },\n      {\n        chatChannelId: channelId,\n        chatStatus: 'active',\n      }\n    );\n\n    res.json({\n      channelId,\n      channelType: 'messaging',\n      members: [petOwnerId, vetId],\n    });\n  } catch (error) {\n    console.error('[Stream] Channel creation error:', error);\n    res.status(500).json({ error: 'Failed to create channel' });\n  }\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Frontend Usage"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Mobile App - in streamChatService.ts\nexport const getAppointmentChannel = async (\n  appointmentId: string,\n  vetId: string,\n  appointmentData?: any,\n) => {\n  const client = getChatClient();\n\n  if (!client.userID) {\n    throw new Error('User must be connected before accessing channels');\n  }\n\n  try {\n    // Request channel from backend\n    const response = await fetch('/api/chat/channels', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        appointmentId,\n        petOwnerId: client.userID,\n        vetId,\n        appointmentTime: appointmentData?.dateTime,\n        activationMinutes: 5,\n      }),\n    });\n\n    const { channelId } = await response.json();\n\n    // Get channel reference\n    const channel = client.channel('messaging', channelId);\n    await channel.watch();\n\n    return channel;\n  } catch (error) {\n    console.error('[Stream] Failed to get channel:', error);\n    throw error;\n  }\n};\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"3-endclose-chat-channel",children:"3. End/Close Chat Channel"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Manually close a chat channel (called by PMS when appointment ends)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Endpoint"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"POST /api/chat/channels/:channelId/end\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Response"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"{\n  success: boolean;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"app.post('/api/chat/channels/:channelId/end', async (req, res) => {\n  try {\n    const { channelId } = req.params;\n\n    // Verify user is vet and has access to this channel\n    const appointment = await Appointment.findOne({\n      chatChannelId: channelId,\n    });\n\n    if (!appointment) {\n      return res.status(404).json({ error: 'Channel not found' });\n    }\n\n    if (appointment.vetId !== req.user.id && req.user.role !== 'admin') {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n\n    const serverClient = StreamChat.getInstance(\n      process.env.STREAM_API_KEY,\n      process.env.STREAM_API_SECRET\n    );\n\n    const channel = serverClient.channel('messaging', channelId);\n\n    // Send system message\n    await channel.sendMessage({\n      text: 'This chat has been ended by the veterinary practice.',\n      user_id: 'system',\n    });\n\n    // Update channel status\n    await channel.update({\n      status: 'ended',\n      frozen: true,  // Optional: prevent new messages\n    });\n\n    // Update database\n    await Appointment.updateOne(\n      { _id: appointment._id },\n      { chatStatus: 'ended' }\n    );\n\n    res.json({ success: true });\n  } catch (error) {\n    console.error('[Stream] Channel end error:', error);\n    res.status(500).json({ error: 'Failed to end channel' });\n  }\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"4-get-active-channels-for-user",children:"4. Get Active Channels for User"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Fetch all active chat channels for a user (used by web PMS to show chat list)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Endpoint"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"GET /api/chat/channels\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query Parameters"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"{\n  role?: 'pet-owner' | 'vet';  // Optional filter\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Response"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"{\n  channels: Array<{\n    id: string;\n    name: string;\n    members: string[];\n    lastMessage?: string;\n    lastMessageAt?: number;\n    appointmentId: string;\n    status: 'active' | 'ended';\n  }>;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"app.get('/api/chat/channels', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const role = req.user.role;\n\n    const serverClient = StreamChat.getInstance(\n      process.env.STREAM_API_KEY,\n      process.env.STREAM_API_SECRET\n    );\n\n    // Query channels where user is a member\n    const filter = {\n      type: 'messaging',\n      members: { $in: [userId] },\n    };\n\n    const sort = [{ last_message_at: -1 }];\n\n    const channels = await serverClient.queryChannels(filter, sort, {\n      watch: true,\n      state: true,\n      presence: true,\n      limit: 100,\n    });\n\n    // Transform response\n    const response = channels.map((ch) => ({\n      id: ch.id,\n      name: ch.data?.name || 'Chat',\n      members: ch.members,\n      lastMessage: ch.state.latestMessages[0]?.text,\n      lastMessageAt: ch.state.latestMessages[0]?.created_at,\n      appointmentId: ch.data?.appointmentId,\n      status: ch.data?.status || 'active',\n    }));\n\n    res.json({ channels: response });\n  } catch (error) {\n    console.error('[Stream] Get channels error:', error);\n    res.status(500).json({ error: 'Failed to fetch channels' });\n  }\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"5-webhook-handler-optional-but-recommended",children:"5. Webhook Handler (Optional but Recommended)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Receive real-time events from Stream (new messages, channel updates, etc.)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Setup in Stream Dashboard"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Go to Stream Dashboard \u2192 Your App"}),"\n",(0,r.jsx)(n.li,{children:'Click "Webhooks" or "Integrations"'}),"\n",(0,r.jsxs)(n.li,{children:["Add webhook URL: ",(0,r.jsx)(n.code,{children:"https://yourbackend.com/api/webhooks/stream"})]}),"\n",(0,r.jsxs)(n.li,{children:["Select events: ",(0,r.jsx)(n.code,{children:"message.new"}),", ",(0,r.jsx)(n.code,{children:"channel.deleted"}),", ",(0,r.jsx)(n.code,{children:"user.updated"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Endpoint"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"POST /api/webhooks/stream\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementation"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const crypto = require('crypto');\n\napp.post('/api/webhooks/stream', (req, res) => {\n  try {\n    // Verify webhook signature\n    const signature = req.headers['x-signature'];\n    const body = JSON.stringify(req.body);\n\n    const hash = crypto\n      .createHmac('sha256', process.env.STREAM_API_SECRET)\n      .update(body)\n      .digest('hex');\n\n    if (signature !== hash) {\n      return res.status(401).json({ error: 'Invalid signature' });\n    }\n\n    const event = req.body;\n\n    // Handle different event types\n    switch (event.type) {\n      case 'message.new':\n        handleNewMessage(event);\n        break;\n\n      case 'channel.deleted':\n        handleChannelDeleted(event);\n        break;\n\n      case 'user.updated':\n        handleUserUpdated(event);\n        break;\n\n      default:\n        console.log('[Stream] Unhandled event type:', event.type);\n    }\n\n    // Always return 200 to acknowledge webhook\n    res.status(200).json({ ok: true });\n  } catch (error) {\n    console.error('[Webhook] Error handling stream event:', error);\n    res.status(500).json({ error: 'Webhook processing failed' });\n  }\n});\n\n// Handler functions\nasync function handleNewMessage(event) {\n  console.log('[Webhook] New message in channel:', event.cid);\n\n  // Get channel and message details\n  const { channel_type, channel_id, message } = event;\n\n  // Example: Send push notification to recipient\n  const appointment = await Appointment.findOne({\n    chatChannelId: `${channel_type}-${channel_id}`,\n  });\n\n  if (appointment) {\n    // Send notification to recipient (vet or pet owner)\n    const recipientId =\n      message.user.id === appointment.petOwnerId\n        ? appointment.vetId\n        : appointment.petOwnerId;\n\n    // Use your notification service (Firebase, Twilio, etc.)\n    // await sendPushNotification(recipientId, {\n    //   title: 'New Message',\n    //   body: message.text || '[Media Message]',\n    //   data: { appointmentId: appointment.id },\n    // });\n  }\n}\n\nasync function handleChannelDeleted(event) {\n  console.log('[Webhook] Channel deleted:', event.cid);\n\n  // Clean up database references if needed\n  // await Appointment.updateOne(\n  //   { chatChannelId: event.cid },\n  //   { chatStatus: 'deleted' }\n  // );\n}\n\nasync function handleUserUpdated(event) {\n  console.log('[Webhook] User updated:', event.user.id);\n\n  // Handle user updates (e.g., profile picture change)\n  // This is optional based on your needs\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"environment-variables",children:"Environment Variables"}),"\n",(0,r.jsxs)(n.p,{children:["Add these to your backend ",(0,r.jsx)(n.code,{children:".env"})," file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Stream Chat Credentials\nSTREAM_API_KEY=your_api_key_here\nSTREAM_API_SECRET=your_api_secret_here\n\n# Database\nMONGODB_URI=mongodb://...\nDATABASE_NAME=yosemite_crew\n\n# Auth\nJWT_SECRET=your_jwt_secret_here\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"database-schema-updates",children:"Database Schema Updates"}),"\n",(0,r.jsx)(n.p,{children:"Update your Appointment model to include chat references:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Appointment model\n{\n  // ... existing fields\n  chatChannelId?: string;           // Stream channel ID\n  chatStatus?: 'pending' | 'active' | 'ended';  // Chat lifecycle status\n  chatActivationMinutes?: number;   // Default: 5 (when chat unlocks)\n  createdAt: Date;\n  updatedAt: Date;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"current-frontend-implementation",children:"Current Frontend Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"mobile-app-react-native",children:"Mobile App (React Native)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Files"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"apps/mobileAppYC/src/features/chat/services/streamChatService.ts"})," - Stream client"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"apps/mobileAppYC/src/features/chat/screens/ChatChannelScreen.tsx"})," - Chat UI"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"apps/mobileAppYC/src/shared/services/mockStreamBackend.ts"})," - Mock service (replace with API calls)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Functions to Update"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"connectStreamUser()"})," - Get token from ",(0,r.jsx)(n.code,{children:"/api/chat/token"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"getAppointmentChannel()"})," - Create channel via ",(0,r.jsx)(n.code,{children:"/api/chat/channels"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"web-app-nextjs",children:"Web App (Next.js)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Files"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"apps/frontend/src/app/services/streamChatService.ts"})," - Stream client"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"apps/frontend/src/app/components/chat/ChatContainer.tsx"})," - Chat UI"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"apps/frontend/src/app/utils/mockStreamBackend.ts"})," - Mock service (replace with API calls)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Functions to Update"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"connectStreamUser()"})," - Get token from ",(0,r.jsx)(n.code,{children:"/api/chat/token"})]}),"\n",(0,r.jsxs)(n.li,{children:["Add chat channel listing (uses ",(0,r.jsx)(n.code,{children:"/api/chat/channels"})," GET endpoint)"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"integration-steps",children:"Integration Steps"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Install Stream SDK on Backend"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install stream-chat\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implement All 5 Endpoints"})," (use examples above)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Configure Environment Variables"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Update Frontend Mock Services"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Replace ",(0,r.jsx)(n.code,{children:"mockStreamBackend.ts"})," calls with HTTP requests to your endpoints"]}),"\n",(0,r.jsx)(n.li,{children:"Keep all existing frontend code unchanged"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Test End-to-End"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Mobile app sends token request \u2192 Backend generates \u2192 Chat connects"}),"\n",(0,r.jsx)(n.li,{children:"Web app lists channels \u2192 Backend queries Stream \u2192 List appears"}),"\n",(0,r.jsx)(n.li,{children:"Send message \u2192 Webhook triggered \u2192 Push notification sent"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Configure Webhooks"})," (optional but recommended):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Set webhook URL in Stream Dashboard"}),"\n",(0,r.jsx)(n.li,{children:"Backend receives events from Stream"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"security-checklist",children:"Security Checklist"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 Never expose ",(0,r.jsx)(n.code,{children:"STREAM_API_SECRET"})," to frontend"]}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Always verify user authentication before token generation"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Validate appointment access (user owns appointment or is vet)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Use HTTPS for all API endpoints"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Implement rate limiting on token endpoint"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Verify webhook signatures from Stream"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Sanitize user input before sending to Stream"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Use environment variables for all credentials"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,r.jsx)(n.h3,{id:"test-token-generation",children:"Test Token Generation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'curl -X POST http://localhost:3000/api/chat/token \\\n  -H "Content-Type: application/json" \\\n  -H "Authorization: Bearer YOUR_JWT_TOKEN" \\\n  -d \'{"userId": "user-123"}\'\n'})}),"\n",(0,r.jsx)(n.h3,{id:"test-channel-creation",children:"Test Channel Creation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'curl -X POST http://localhost:3000/api/chat/channels \\\n  -H "Content-Type: application/json" \\\n  -H "Authorization: Bearer YOUR_JWT_TOKEN" \\\n  -d \'{\n    "appointmentId": "apt-123",\n    "petOwnerId": "owner-1",\n    "vetId": "vet-1",\n    "appointmentTime": "2025-01-15T14:00:00Z"\n  }\'\n'})}),"\n",(0,r.jsx)(n.h3,{id:"test-get-channels",children:"Test Get Channels"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'curl -X GET http://localhost:3000/api/chat/channels \\\n  -H "Authorization: Bearer YOUR_JWT_TOKEN"\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"deployment-notes",children:"Deployment Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Stream Cloud handles all message delivery and persistence"}),"\n",(0,r.jsx)(n.li,{children:"Your backend only manages authentication and channel creation"}),"\n",(0,r.jsx)(n.li,{children:"No need to deploy Stream locally"}),"\n",(0,r.jsx)(n.li,{children:"Use Stream Dashboard for monitoring and management"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"support",children:"Support"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Stream Docs: ",(0,r.jsx)(n.a,{href:"https://getstream.io/chat/docs/api/",children:"https://getstream.io/chat/docs/api/"})]}),"\n",(0,r.jsxs)(n.li,{children:["Community: ",(0,r.jsx)(n.a,{href:"https://getstream.io/chat/docs/sdk/react-native/#community",children:"https://getstream.io/chat/docs/sdk/react-native/#community"})]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Backend implementation is ready to start!"})," \ud83d\ude80"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},2303:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var s=t(2155);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);